{"version":3,"sources":["../src/commands/start.ts","../src/index.ts","../src/utils/get-package-info.ts"],"sourcesContent":["import { Command } from \"commander\";\nimport path from \"path\";\nimport { promises as fs } from \"fs\";\nimport { execSync } from \"child_process\";\nimport prompts from \"prompts\";\n\nconst repos = [\n  { name: \"client\", url: \"https://github.com/example/client-repo.git\" },\n  { name: \"contracts\", url: \"https://github.com/example/contracts-repo.git\" },\n];\n\nasync function init(projectName: string, cwd: string) {\n  const projectPath = path.join(cwd, projectName);\n\n  // Create project directory\n  await fs.mkdir(projectPath, { recursive: true });\n\n  // Clone repositories\n  for (const repo of repos) {\n    console.log(`Cloning ${repo.name} repository...`);\n    execSync(`git clone ${repo.url} ${path.join(projectPath, repo.name)}`, {\n      stdio: \"inherit\",\n    });\n  }\n\n  // Create README\n  const readmePath = path.join(projectPath, \"README.md\");\n  const readmeContent = `# ${projectName}\\n\\nThis project contains:\\n- Client\\n- Contracts`;\n  await fs.writeFile(readmePath, readmeContent);\n\n  console.log(`Project initialized at ${projectPath}`);\n}\n\nexport const start = new Command()\n  .name(\"start\")\n  .description(\"initialize a new project with client and contracts repositories\")\n  .option(\"-c, --cwd <cwd>\", \"the working directory\", process.cwd())\n  .action(async (options) => {\n    try {\n      const cwd = path.resolve(options.cwd);\n\n      // Prompt for project name\n      const response = await prompts({\n        type: \"text\",\n        name: \"projectName\",\n        message: \"What would you like to name your project?\",\n      });\n\n      if (!response.projectName) {\n        console.error(\"Project name is required.\");\n        process.exit(1);\n      }\n\n      await init(response.projectName, cwd);\n      console.log(\"Initialization complete\");\n    } catch (error) {\n      console.error(\"An error occurred:\", error);\n      process.exit(1);\n    }\n  });\n","\n// #!/usr/bin/env node\nimport { start } from \"./commands/start\"\n\nimport { Command } from \"commander\"\n\nimport { getPackageInfo } from \"./utils/get-package-info\"\n\nprocess.on(\"SIGINT\", () => process.exit(0))\nprocess.on(\"SIGTERM\", () => process.exit(0))\n\nasync function main() {\n  const packageInfo = await getPackageInfo()\n\n  const program = new Command()\n    .name(\"@dojoengine\")\n    .description(\"install a dojoc client\")\n    .version(\n      packageInfo.version || \"1.0.0\",\n      \"-v, --version\",\n      \"display the version number\"\n    )\n\n  program.addCommand(start)\n\n  program.parse()\n}\n\nmain()\n\n// import spawn from \"cross-spawn\";\n// import * as fs from \"fs\";\n// import https from \"https\";\n// import path from \"path\";\n\n// import { input, select } from \"@inquirer/prompts\";\n\n// const templates = [\n//     {\n//         value: \"react-app\",\n//         description: \"React app using Dojo\",\n//     },\n//     {\n//         value: \"react-phaser-example\",\n//         description: \"React/Phaser app using Dojo\",\n//     },\n//     {\n//         value: \"react-pwa-app\",\n//         description: \"React Progressive Web Apps using Dojo\",\n//     },\n//     {\n//         value: \"react-threejs\",\n//         description: \"React Threejs using Dojo\",\n//     },\n// ];\n\n// run();\n\n// async function run() {\n//     try {\n//         const { template, projectName } = await prompt();\n\n//         // Create the main project directory\n//         const projectPath = path.join(process.cwd(), projectName);\n//         fs.mkdirSync(projectPath, { recursive: true });\n\n//         // Create client and dojo-starter directories inside the main project directory\n//         const clientPath = path.join(projectPath, 'client');\n//         const dojoStarterPath = path.join(projectPath, 'dojo-starter');\n//         fs.mkdirSync(clientPath, { recursive: true });\n//         fs.mkdirSync(dojoStarterPath, { recursive: true });\n\n//         // clone template using degit into client directory\n//         console.log(`Downloading ${template} into client directory...`);\n//         spawn.sync(\"npx\", [\n//             \"degit\",\n//             `dojoengine/dojo.js/examples/react/${template}`,\n//             clientPath, // Cloning directly into the client directory\n//         ]);\n\n//         // Ensure the client directory exists before rewriting package.json\n//         if (!fs.existsSync(clientPath)) {\n//             throw new Error(`Client directory not found at ${clientPath}`);\n//         }\n\n//         // rewrite package.json in client directory\n//         await rewritePackageJson(projectName);\n\n//         // clone dojo-starter into the dojo-starter directory\n//         console.log(`Downloading dojo-starter...`);\n//         spawn.sync(\"npx\", [\"degit\", `dojoengine/dojo-starter`, dojoStarterPath]);\n        \n//         console.log(\"Congrats! Your new project has been set up successfully.\\n\");\n//         console.log(`Navigate into your project directory with:\\n  cd ${projectName}\\n`);\n//         console.log(\"You can then build the starter and run the client.\\n\");\n//         console.log(\"For detailed instructions, follow the README here:\\n\");\n\n//         console.log('https://book.dojoengine.org/cairo/hello-dojo');\n\n//     } catch (e) {\n//         console.error(`Error: ${e}`);\n//     }\n// }\n\n// async function rewritePackageJson(projectName: string) {\n//     // The package.json is expected to be in the 'client' subdirectory\n//     const clientPath = path.join(process.cwd(), projectName, 'client');\n//     process.chdir(clientPath);\n\n//     const packageJsonPath = path.join(\"package.json\");\n//     // Check if package.json exists before reading it\n//     if (!fs.existsSync(packageJsonPath)) {\n//         throw new Error(`package.json not found in ${clientPath}`);\n//     }\n//     const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, \"utf-8\"));\n//     const latestVersion = await getLatestVersion();\n\n//     // rename using projectName\n//     packageJson.name = projectName;\n\n//     // rewrite all link:dojo-packages/packages/... with latest version\n//     for (let dep of Object.keys(packageJson.dependencies)) {\n//         if (\n//             dep.startsWith(\"@dojoengine\") &&\n//             packageJson.dependencies[dep].startsWith(\"workspace:\")\n//         ) {\n//             packageJson.dependencies[dep] = latestVersion;\n//         }\n//     }\n\n//     fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));\n// }\n\n// async function prompt(): Promise<{ template: string; projectName: string }> {\n//     const template = await select({\n//         message: \"Select a template\",\n//         choices: templates,\n//     });\n\n//     const projectName = await input({\n//         message: \"Project name \",\n//         validate: (input: string) => {\n//             if (/^([A-Za-z\\-\\_\\d])+$/.test(input)) return true;\n//             else\n//                 return \"Project name may only include letters, numbers, underscores and hashes.\";\n//         },\n//         default: template,\n//     });\n\n//     return { template, projectName };\n// }\n\n// async function getLatestVersion(): Promise<string> {\n//     return new Promise((resolve, reject) => {\n//         https\n//             .get(\n//                 \"https://registry.npmjs.org/-/package/@dojoengine/core/dist-tags\",\n//                 (res) => {\n//                     if (res.statusCode === 200) {\n//                         let body = \"\";\n//                         res.on(\"data\", (data) => (body += data));\n//                         res.on(\"end\", () => {\n//                             resolve(JSON.parse(body).latest);\n//                         });\n//                     } else {\n//                         reject();\n//                     }\n//                 }\n//             )\n//             .on(\"error\", () => {\n//                 reject();\n//             });\n//     });\n// }\n","import path from \"path\"\nimport fs from \"fs-extra\"\nimport { type PackageJson } from \"type-fest\"\n\nexport function getPackageInfo() {\n  const packageJsonPath = path.join(\"package.json\")\n\n  return fs.readJSONSync(packageJsonPath) as PackageJson\n}"],"mappings":";AAAA,SAAS,eAAe;AACxB,OAAO,UAAU;AACjB,SAAS,YAAY,UAAU;AAC/B,SAAS,gBAAgB;AACzB,OAAO,aAAa;AAEpB,IAAM,QAAQ;AAAA,EACZ,EAAE,MAAM,UAAU,KAAK,6CAA6C;AAAA,EACpE,EAAE,MAAM,aAAa,KAAK,gDAAgD;AAC5E;AAEA,eAAe,KAAK,aAAqB,KAAa;AACpD,QAAM,cAAc,KAAK,KAAK,KAAK,WAAW;AAG9C,QAAM,GAAG,MAAM,aAAa,EAAE,WAAW,KAAK,CAAC;AAG/C,aAAW,QAAQ,OAAO;AACxB,YAAQ,IAAI,WAAW,KAAK,IAAI,gBAAgB;AAChD,aAAS,aAAa,KAAK,GAAG,IAAI,KAAK,KAAK,aAAa,KAAK,IAAI,CAAC,IAAI;AAAA,MACrE,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAGA,QAAM,aAAa,KAAK,KAAK,aAAa,WAAW;AACrD,QAAM,gBAAgB,KAAK,WAAW;AAAA;AAAA;AAAA;AAAA;AACtC,QAAM,GAAG,UAAU,YAAY,aAAa;AAE5C,UAAQ,IAAI,0BAA0B,WAAW,EAAE;AACrD;AAEO,IAAM,QAAQ,IAAI,QAAQ,EAC9B,KAAK,OAAO,EACZ,YAAY,iEAAiE,EAC7E,OAAO,mBAAmB,yBAAyB,QAAQ,IAAI,CAAC,EAChE,OAAO,OAAO,YAAY;AACzB,MAAI;AACF,UAAM,MAAM,KAAK,QAAQ,QAAQ,GAAG;AAGpC,UAAM,WAAW,MAAM,QAAQ;AAAA,MAC7B,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,IACX,CAAC;AAED,QAAI,CAAC,SAAS,aAAa;AACzB,cAAQ,MAAM,2BAA2B;AACzC,cAAQ,KAAK,CAAC;AAAA,IAChB;AAEA,UAAM,KAAK,SAAS,aAAa,GAAG;AACpC,YAAQ,IAAI,yBAAyB;AAAA,EACvC,SAAS,OAAO;AACd,YAAQ,MAAM,sBAAsB,KAAK;AACzC,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF,CAAC;;;ACvDH,SAAS,WAAAA,gBAAe;;;ACJxB,OAAOC,WAAU;AACjB,OAAOC,SAAQ;AAGR,SAAS,iBAAiB;AAC/B,QAAM,kBAAkBD,MAAK,KAAK,cAAc;AAEhD,SAAOC,IAAG,aAAa,eAAe;AACxC;;;ADAA,QAAQ,GAAG,UAAU,MAAM,QAAQ,KAAK,CAAC,CAAC;AAC1C,QAAQ,GAAG,WAAW,MAAM,QAAQ,KAAK,CAAC,CAAC;AAE3C,eAAe,OAAO;AACpB,QAAM,cAAc,MAAM,eAAe;AAEzC,QAAM,UAAU,IAAIC,SAAQ,EACzB,KAAK,aAAa,EAClB,YAAY,wBAAwB,EACpC;AAAA,IACC,YAAY,WAAW;AAAA,IACvB;AAAA,IACA;AAAA,EACF;AAEF,UAAQ,WAAW,KAAK;AAExB,UAAQ,MAAM;AAChB;AAEA,KAAK;","names":["Command","path","fs","Command"]}